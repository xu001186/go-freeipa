// Code generated by `github.com/ccin2p3/go-freeipa/gen` - DO NOT EDIT.

package freeipa;

import (
  "time"
	"encoding/json"
  "fmt"

)

var apiVersion = "{{.Schema.Version}}"

type request struct {
  Method string `json:"method"`
  Params []interface{} `json:"params"`
}

{{range .Schema.Commands}}
/*
{{TrimSpace .Doc}}
*/
func (c *Client) {{.UpperName}}(
  {{range .PosParams -}}
    {{.LowerName}} {{ToGoType .Type}}, // {{.Doc}}
  {{end -}}
  reqArgs *{{.UpperName}}Args,
  optArgs *{{.UpperName}}OptionalArgs, // can be nil
) (*{{.UpperName}}Result, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := {{.LowerName}}KwParams{
    {{.UpperName}}Args: reqArgs,
    {{.UpperName}}OptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "{{.Name}}",
    Params: []interface{}{
      []interface{}{
        {{- range .PosParams}}{{.LowerName}}, {{end -}}
      }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res {{.LowerName}}Response
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type {{.UpperName}}Args struct {
  {{range .KwParams}}
  {{- if .Required}}
    /*
{{.Label}}
{{.Doc}}
    */
    {{.UpperName}} {{if .Multivalue}}[]{{end}}{{ToGoType .Type}} `json:"{{.Name}},omitempty"`
  {{end -}}
  {{end -}}
}

type {{.UpperName}}OptionalArgs struct {
  {{range .KwParams}}
  {{- if not .Required}}
    /*
{{.Label}}
{{.Doc}}
    */
    {{.UpperName}} *{{if .Multivalue}}[]{{end}}{{ToGoType .Type}} `json:"{{.Name}},omitempty"`
  {{end -}}
  {{end -}}
}

type {{.LowerName}}KwParams struct {
  *{{.UpperName}}Args
  *{{.UpperName}}OptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type {{.LowerName}}Response struct {
	Error  *Error      `json:"error"`
	Result *{{.UpperName}}Result `json:"result"`
}
type {{.UpperName}}Result struct {
  {{$callLowerName := .LowerName }}
  {{$cmd := .}}
  {{range .Output}}
    /*
{{.Doc}}
    ({{if .Required}}required{{else}}optional{{end}})
    */
    {{ if eq "failed" .LowerName}}
    {{.UpperName}} FailedOperations`json:"failed,omitempty"`
    {{ else }}
    {{.UpperName}} {{if not .Required}}*{{end}}{{if .Multivalue}}[]{{end}}{{.GoType $cmd}} `json:"{{.Name}},omitempty"`
    {{ end }}
  {{end -}}
}

func (t *{{.UpperName}}Result) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("{{.UpperName}}Result[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("{{.UpperName}}Result%v", string(b))
}
{{end}}

{{range .Schema.Classes}}


type {{.UpperName}} struct {
  {{range .Params}}
    /*
{{.Label}}
{{.Doc}}
    */
    {{.UpperName}} {{if not .Required}}*{{end}} interface{} `json:"{{.Name}},omitempty"`
  {{end -}}
}

func (t *{{.UpperName}}) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("{{.UpperName}}[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("{{.UpperName}}%v", string(b))
}




{{end}}

{{range .Errs}}
const {{.Name}}Code = {{.Errno}}
{{end}}